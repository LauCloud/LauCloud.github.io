<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JSP," />








  <link rel="shortcut icon" type="image/x-icon" href="/website.jpg?v=5.1.0" />






<meta name="description" content="这篇文章主要是想介绍的是文件上传和下载，因为在很多时候，这两个是非常常见的，比如我们下载音乐或者电影，还有我们将简历上传到招聘网站，这些都会用到文件的上传和下载，因此，当我们掌握了这两个技术之后，就可以实现很多这方面的功能，而我们的技术实力也会根据学到更多的新知识而变强。">
<meta property="og:type" content="article">
<meta property="og:title" content="文件上传和下载">
<meta property="og:url" content="http://yoursite.com/2017/12/28/文件上传和下载/index.html">
<meta property="og:site_name" content="云开">
<meta property="og:description" content="这篇文章主要是想介绍的是文件上传和下载，因为在很多时候，这两个是非常常见的，比如我们下载音乐或者电影，还有我们将简历上传到招聘网站，这些都会用到文件的上传和下载，因此，当我们掌握了这两个技术之后，就可以实现很多这方面的功能，而我们的技术实力也会根据学到更多的新知识而变强。">
<meta property="og:updated_time" content="2018-10-04T09:19:08.861Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="文件上传和下载">
<meta name="twitter:description" content="这篇文章主要是想介绍的是文件上传和下载，因为在很多时候，这两个是非常常见的，比如我们下载音乐或者电影，还有我们将简历上传到招聘网站，这些都会用到文件的上传和下载，因此，当我们掌握了这两个技术之后，就可以实现很多这方面的功能，而我们的技术实力也会根据学到更多的新知识而变强。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/28/文件上传和下载/"/>





  <title> 文件上传和下载 | 云开 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">云开</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">努力成长，To be strong!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            爱心公益
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/28/文件上传和下载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lau Cloud">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云开">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                文件上传和下载
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T17:14:45+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/12/28/文件上传和下载/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/12/28/文件上传和下载/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/12/28/文件上传和下载/" class="leancloud_visitors" data-flag-title="文件上传和下载">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这篇文章主要是想介绍的是文件上传和下载，因为在很多时候，这两个是非常常见的，比如我们下载音乐或者电影，还有我们将简历上传到招聘网站，这些都会用到文件的上传和下载，因此，当我们掌握了这两个技术之后，就可以实现很多这方面的功能，而我们的技术实力也会根据学到更多的新知识而变强。</p>
<a id="more"></a>
<h3 id="1-文件上传简介"><a href="#1-文件上传简介" class="headerlink" title="1.文件上传简介"></a>1.文件上传简介</h3><p>什么是文件上传呢？其实就是将我们本地的文件传到服务器上面，而在 <code>Java</code> 中的话，想将本地文件传到服务器上面，肯定就是使用文件流了，其实文件上传的技术有很多，比如：</p>
<pre><code>FileUpload
Servlet 3.0
Struts2
</code></pre><p>我们在这里的话，主要是想介绍的是使用 <code>FileUpload</code> 这个工具来上传文件，使用这个工具上传文件也比较简单，我们会在后面进行详细说明。</p>
<h3 id="2-文件上传的原理"><a href="#2-文件上传的原理" class="headerlink" title="2.文件上传的原理"></a>2.文件上传的原理</h3><p>在说文件上传的原理之前，我们先看看文件上传必须有哪些要素，在上传文件时肯定是需要有一个表单的，那么这个表单元素需要满足哪些条件呢？其实是有 <code>3</code> 个的。</p>
<pre><code>1.表单提交的方式必须是POST方式；
2.表单中需要有&lt;input type=&quot;file&quot;&gt;元素，并且该元素中需要有name属性和相应的值；
3.表单元素中的enctype属性需要赋值为multipart/form-data。
</code></pre><p>先说第 <code>1</code> 个，表单提交方式必须是 <code>POST</code> 方式，这是因为 <code>GET</code> 提交方式是有大小限制的，如果我们要上传的文件大小比较大的话，肯定就不行了；第 <code>2</code> 个，表单中需要有 <code>&lt;input type=&quot;file&quot;&gt;</code> 的元素，这是因为只有该元素才能让我们选择文件进行上传，不然的话我们也做不了上传操作；第 <code>3</code> 个，<code>enctype</code> 的取值必须是 <code>multipart/form-data</code> ，这是因为如果该属性取默认值 <code>application/x-www-form-urlencoded</code> 的话，那我们提交表单时，是不会将选中文件中的数据也带过去的，因此我们在服务器端是接受不到数据的，其实我们是可以进行演示的。</p>
<p>比如我们有一个表单，当我们为该表单的 <code>enctype</code> 属性赋值为默认值 <code>application/x-www-form-urlencoded</code> 时，表单的代码应该是：</p>
<pre><code>&lt;form action=&quot;${ pageContext.request.contextPath }/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
    文件说明：&lt;input type=&quot;text&quot; name=&quot;info&quot;&gt;&lt;br&gt;
    文件上传：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value =&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre><p>我们在第 <code>1</code> 个普通的文本输入项里面输入 <code>aa</code>，然后在下面的文件选择项中选择 <code>D</code> 盘中的 <code>aa.txt</code> 时，需要说明的是 <code>aa.txt</code> 中的文本内容为 <code>hello</code>，然后点击提交按钮，我们就可以看到请求的报文为：</p>
<pre><code>POST /FileUpload/uploadServlet HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Content-Length: 25
Pragma: no-cache
Cache-Control: no-cache
Origin: http://localhost:8080
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: http://localhost:8080/FileUpload/jsp/upload.jsp
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie: JSESSIONID=660141415A34D23305B59CD1D967FE7E

info=aa&amp;uploadFile=aa.txt
</code></pre><p>其实前面的报文就是请求行和请求头了，最后一行才是请求体，但是我们观察请求体的话，就可以发现对于文件上传项来说，它只上传了文件的名称，而文件中具体包含什么内容是没有带上的，因此我们在后台也是接受不到数据的。</p>
<p>下面我们再将表单元素中的 <code>enctype</code> 属性赋值为 <code>multipart/form-data</code> 属性，相应的表单代码为：</p>
<pre><code>&lt;form action=&quot;${ pageContext.request.contextPath }/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    文件说明：&lt;input type=&quot;text&quot; name=&quot;info&quot;&gt;&lt;br&gt;
    文件上传：&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value =&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre><p>然后我们和上面一样，也是在普通文本输入项中输入 <code>aa</code>，然后在文本选择项中选择文件 <code>aa.txt</code>，最后也是点击上传，我们会看到相应的报文：</p>
<pre><code>POST /FileUpload/uploadServlet HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Content-Length: 284
Pragma: no-cache
Cache-Control: no-cache
Origin: http://localhost:8080
Upgrade-Insecure-Requests: 1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryH8GeNXAhzwxrL3F1
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.84 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: http://localhost:8080/FileUpload/uploadServlet
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cookie: JSESSIONID=660141415A34D23305B59CD1D967FE7E

----WebKitFormBoundaryH8GeNXAhzwxrL3F1
Content-Disposition: form-data; name=&quot;info&quot;

aa
----WebKitFormBoundaryH8GeNXAhzwxrL3F1
Content-Disposition: form-data; name=&quot;uploadFile&quot;; filename=&quot;D:\aa.txt&quot;
Content-Type: text/plain

hello
----WebKitFormBoundaryH8GeNXAhzwxrL3F1--
</code></pre><p>其实比较两次的请求信息的话，可以发现其实两者在请求行和请求头的差别不是很大的，但需要注意的是第 <code>2</code> 次请求时的 <code>Content-Type</code> 请求头，里面有一个 <code>boundary=----WebKitFormBoundaryH8GeNXAhzwxrL3F1</code>，这个是什么意思呢？其实 <code>boundary</code> 就是分隔符的意思，因此当我们看下面的请求体时，就会发现请求体中的内容是被 <code>----WebKitFormBoundaryH8GeNXAhzwxrL3F1</code> 这个分隔符所分割开的，那我们就可以开始看请求体中的内容了。</p>
<pre><code>----WebKitFormBoundaryH8GeNXAhzwxrL3F1
Content-Disposition: form-data; name=&quot;info&quot;

aa
----WebKitFormBoundaryH8GeNXAhzwxrL3F1
Content-Disposition: form-data; name=&quot;uploadFile&quot;; filename=&quot;D:\aa.txt&quot;
Content-Type: text/plain

hello
----WebKitFormBoundaryH8GeNXAhzwxrL3F1--
</code></pre><p>可以很明显的看到，我们上面的分隔符将请求体分为了两个部分，第一个部分当然就是我们的普通文本输入项了，可以看到该普通项的 <code>name</code> 属性以及属性值，其实除了文件项之外的所有输入项我们都可以叫做普通项，那下面的一个就是文件上传项了，可以看到其中的 <code>name</code> 属性，然后文件上传项比普通项多的就是 <code>filename</code> 这个属性了，也就是我们上传的文件名称，最后的话也可以看到我们所上传文件里面的内容为 <code>hello</code>。</p>
<p>介绍了上面的内容之后，我们知道，在提交的表单之中，是分为普通项和文件上传项的，那我们想写代码实现的话思路应该是怎样的呢？其实可以这样：</p>
<pre><code>1.首先获得分隔符；
2.获得请求体的全部内容(request.getInputStream());
3.利用分隔符将获得的内容进行分割;
4.判断分割之后的部分是普通项还是文件上传项
    普通项：获得普通项名称和值；
    文件上传项：获得文件名称和文件内容，并通过文件流写到服务器上。
</code></pre><p>其实上面这也就是文件上传的原理了，我们后面编程也是根据这个原则来做的。</p>
<h3 id="3-文件上传的代码实现"><a href="#3-文件上传的代码实现" class="headerlink" title="3.文件上传的代码实现"></a>3.文件上传的代码实现</h3><p>因为是使用的 <code>FileUpload</code> 这个工具，所以我们在使用之前必须要先导入相应的 <code>jar</code> 包，这里的话就是：</p>
<pre><code>commons-fileupload-1.2.1.jar
commons-io-1.4.jar
</code></pre><p>上面还导入了 <code>io</code> 的包也是因为依赖的关系，毕竟底层还是使用的文件流。</p>
<p>因为上面在介绍原理的时候已经粘贴过前台 <code>JSP</code> 页面之中的表单元素了，因此我们这里就只介绍后端代码了。</p>
<p><strong>UploadServlet</strong></p>
<pre><code>// 1.创建磁盘文件项工厂
DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();
// 2.创建核心解析类
ServletFileUpload servletFileUpload = new ServletFileUpload(
        diskFileItemFactory);
// 3.利用解析类解析请求对象，解析后得到多个部分。为一个List集合，其中元素则为文件项(FileItem)
List&lt;FileItem&gt; fileItemList = servletFileUpload.parseRequest(request);
// 4.遍历文件项集合，得到每个文件项对象，根据文件项判断是否为文件上传项
for (FileItem fileItem : fileItemList) {
    // 判断该文件项是普通项还是文件上传项
    if(fileItem.isFormField()) {
        // 普通项
        // 接受普通项的值，不能再使用request.getParameter()
        String fieldName = fileItem.getFieldName();
        String fieldValue = fileItem.getString(StandardCharsets.UTF_8.toString());
        System.out.println(fieldName+&quot;---&quot;+fieldValue);
    }else {
        // 文件上传项
        // 获取文件的名称
        String fileName = fileItem.getName();
        // 获取文件的数据
        InputStream inputStream = fileItem.getInputStream();
        // 获得文件上传的路径：磁盘绝对路径
        String realPath = this.getServletContext().getRealPath(&quot;/upload&quot;);
        OutputStream outputStream = new FileOutputStream(new File(realPath+&quot;/&quot;+fileName));
        int len = 0;
        byte[] bytes = new byte[1024];
        while((len = inputStream.read(bytes))!= -1) {
            outputStream.write(bytes, 0, len);
        }
        inputStream.close();
        outputStream.close();
    }
}
</code></pre><p>其实上面的代码就是根据我们之前整理的思路来写的，只是因为 <code>FileUpload</code> 这个工具为我们封装了很多工具类，因此使用起来就非常简单了，首先是创建一个磁盘文件项工厂，然后再将该工厂对象传入到我们核心解析器的构造方法之中，来获取核心解析器，然后就可以使用解析器来解析请求对象，获得一个包含普通项和文件上传项的集合对象，我们就可以遍历该集合对象，然后如果是普通项，则可以获取属性名以及属性值了，如果是文件上传项的话，则可以获取文件名称以及将文件数据写入到服务器当中了。当然我们在下面还会对各个重要类的 <code>api</code> 进行详细的介绍。</p>
<h3 id="4-DiskFileItemFactory-磁盘文件项工厂"><a href="#4-DiskFileItemFactory-磁盘文件项工厂" class="headerlink" title="4.DiskFileItemFactory(磁盘文件项工厂)"></a>4.DiskFileItemFactory(磁盘文件项工厂)</h3><p>我们在上面的代码中已经使用过 <code>DiskFileItemFactory</code> 这个类了，并且就是使用的它的构造方法，但是我们还需要注意的是其实它还有一个重载构造器方法，先将两个构造器方法分别列在下面：</p>
<pre><code>public DiskFileItemFactory()
public DiskFileItemFactory(int sizeThreshold,java.io.File repository)
</code></pre><p>我们在这里可以了解一下第 <code>2</code> 个构造器方法中的 <code>sizeThreshold</code> 以及 <code>repository</code> 这两个参数分别代表什么意思呢？其实我们再看 <code>DiskFileItemFactory</code> 这个类的方法的话，会发现还有两个方法与我们上面的这两个参数有关，那就是：</p>
<pre><code>public void setSizeThreshold(int sizeThreshold)
public void setRepository(java.io.File repository)
</code></pre><p>这里也就很明白了，就是说 <code>sizeThreshold</code> 和 <code>repository</code> 这两个参数既可以在类的构造器中指定，也可以单独使用 <code>set</code> 方法来进行指定，那到底这两个参数是什么意思呢？其实 <code>sizeThreshold</code> 这个参数是设置缓冲区的大小，如果我们不进行设置的话，就是取默认值 <code>10kb</code> 了，而 <code>repository</code> 则是设置临时文件存放的目录。那我们就可以在使用这两个参数来进行缓冲区以及临时文件目录的设置了。</p>
<pre><code>// 1.创建磁盘文件项工厂
DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();
// 1.1 设置缓冲区大小为3M
diskFileItemFactory.setSizeThreshold(3*1024*1024);
// 1.2 设置临时文件存放的目录
String tempPath = this.getServletContext().getRealPath(&quot;/temp&quot;);
diskFileItemFactory.setRepository(new File(tempPath));
</code></pre><p>当我们上传的文件大小比较大时，比如是上传的视频文件，那就可能会产生临时文件存放在临时目录了，其实这个临时文件也是可以用作断点续传的功能的，当然在这里文件上传成功之后临时文件也是不会删除的，如果想要上传成功之后删除临时文件，还需要使用下面会介绍的 <code>FileItem</code> 类。</p>
<h3 id="5-ServletFileUpload-核心解析类"><a href="#5-ServletFileUpload-核心解析类" class="headerlink" title="5.ServletFileUpload(核心解析类)"></a>5.ServletFileUpload(核心解析类)</h3><p>下面我们再来看看 <code>ServletFileUpload</code> 这个核心解析类的相关 <code>api</code>，在上面的代码中我们已经使用了它的构造器方法，其实它也是有 <code>2</code> 个构造器方法的。</p>
<pre><code>public ServletFileUpload()
public ServletFileUpload(FileItemFactory fileItemFactory)
</code></pre><p>在上面我们是使用的有参构造器，即传入了磁盘文件项工厂对象的，其实我们也可以使用无参构造器，但是如果使用无参构造器的话，就需要在解析请求对象之前，调用 <code>setFileItemFactory()</code> 设置一个文件磁盘项工厂对象。</p>
<p>当然 <code>ServletFileUpload</code> 还有很多有用的方法，下面一一列举说明：</p>
<pre><code>public static final boolean isMultipartContent(javax.servlet.http.HttpServletRequest request)
</code></pre><p>这个方法可以用来判断我们上传文件表单的 <code>enctype</code> 属性是否赋值为 <code>multipart/form-data</code>，如果是那就会返回 <code>true</code>，否则的话就会返回 <code>false</code>，那我们就可以在后台的最开始使用该方法先进行判断一下，如果是的话才应该继续往下走，不是的话则应该给出提示，并返回到上传文件页面了。</p>
<pre><code>boolean flag = ServletFileUpload.isMultipartContent(request);
if(!flag) {
    // enctype属性不是multipart/form-data
    request.setAttribute(&quot;msg&quot;, &quot;上传文件表单格式不正确！请修改enctype属性！&quot;);
    request.getRequestDispatcher(&quot;/jsp/upload.jsp&quot;).forward(request, response);
}
</code></pre><p>当然我们前台的上传文件 <code>JSP</code> 也应该加入相应的代码了。</p>
<pre><code>&lt;h3&gt;&lt;font color=&quot;red&quot;&gt;${ msg }&lt;/font&gt;&lt;/h3&gt;
</code></pre><p>这样就能够判断上传文件表单中的 <code>enctype</code> 属性是否正确了。</p>
<p>当然这个类中最重要的方法应该还是解析请求对象，然后获取得到普通项和文件上传项的 <code>List</code> 集合这个方法了，这个方法是在 <code>ServletFileUpload</code> 的父类的父类 <code>FileUploadBase</code> 中的。</p>
<pre><code>public java.util.List parseRequest(javax.servlet.http.HttpServletRequest req)
</code></pre><p>还有一些有用的方法，比如设置上传文件最大大小的。</p>
<pre><code>public void setFileSizeMax(long fileSizeMax)
public void setSizeMax(long sizeMax)
</code></pre><p>上面两个方法虽然都是设置上传文件大小的，但还是有区别的，第 <code>1</code> 个方法 <code>setFileSizeMax()</code> 是设置单个文件的最大大小的，而第 <code>2</code> 个方法 <code>setSizeMax()</code> 则是设置一次请求中所有文件的大小的。</p>
<p>还有就是防止中文文件名乱码的方法。</p>
<pre><code>public void setHeaderEncoding(java.lang.String encoding)
</code></pre><p>最后一个就是可以为我们上传文件时设置一个监听器，而我们就可以利用该监听器完成别的功能，比如显示文件上传的进度。</p>
<pre><code>public void setProgressListener(ProgressListener pListener)
</code></pre><h3 id="6-FileItem-文件项"><a href="#6-FileItem-文件项" class="headerlink" title="6.FileItem(文件项)"></a>6.FileItem(文件项)</h3><p>我们在表单元素中的每一个元素都对应着一个 <code>FileItem</code>，如果是一个文件上传组件，那就对应着文件上传项，而如果是普通文本输入项，那就是普通项了，而我们要区分这两者的话，<code>FileItem</code> 中也提供了相应的方法。</p>
<pre><code>boolean isFormField()
</code></pre><p>就是上面这个 <code>isFormField()</code> 这个方法，如果返回 <code>true</code> 的话，则表示是一个普通项，如果返回 <code>false</code> 的话，就表示是一个文件上传项。</p>
<p>如果是普通项的话，那我们最常见的操作就会获取其中的属性名称和属性值了，<code>FileItem</code> 中当然就已经有相应的方法了。</p>
<pre><code>java.lang.String getFieldName()
java.lang.String getString()
java.lang.String getString(java.lang.String encoding)
</code></pre><p>第 <code>1</code> 个方法 <code>getFieldName()</code> 就是获得普通项的名称了，而后面的两个重载方法 <code>getString()</code> 则是获取普通项值的方法了，第 <code>2</code> 个重载方法可以传入一种字符集的名称，很显然这样就可以很好的支持中文，防止乱码了。</p>
<p>上面就是普通项会使用到的方法了，下面再看文件上传项会使用到的方法。</p>
<pre><code>java.lang.String getName()
</code></pre><p>这个方法就是用来获取文件上传项中的名称的，当然对于文件上传项来说的话，其实就是文件名称了。</p>
<pre><code>java.io.InputStream getInputStream()
</code></pre><p>这个方法就是用来获取文件内容的方法了，因为文件的格式是多种多样的，不仅有文本文件，还有音乐和视频，所以使用流的方式处理是最好的了。</p>
<pre><code>long getSize()
</code></pre><p>这个方法是用来获取我们上传文件的大小的，之前 <code>ServletFileUpload</code> 类中不是有 <code>setFileSizeMax()</code> 方法来设置上传文件最大的大小吗？其实它还有一个 <code>getFileSizeMax()</code> 方法是用来获取文件最大限制大小的，那我们就可以先使用该获取文件大小的方法与限制文件最大的大小比较一下，看文件大小是否是在最大值以内。</p>
<p>之前在说 <code>DiskFileItemFactory</code> 类的时候，我们说到了临时文件，当我们文件上传成功之后，临时文件是不会被删除掉的，那如果我们想要删除掉的话，应该怎么办呢？其实可以使用下面这个方法：</p>
<pre><code>void delete()
</code></pre><p>这样的话，在我们将文件成功上传之后，临时文件也会被删除了。</p>
<h3 id="7-案例：多文件上传"><a href="#7-案例：多文件上传" class="headerlink" title="7.案例：多文件上传"></a>7.案例：多文件上传</h3><p>现在是想做一个小功能，在页面中有两个按钮，一个添加按钮，一个提交按钮，当点击添加按钮时，就会出现一个文件选择框，而在文件选择框后面还跟着一个删除按钮，可以在页面中删除自身以及前面对应的文件选择框，这样我们就可以选择任意多个文件进行上传了，当最后点击上传按钮时，所有的文件就都可以上传了。</p>
<p>我们首先看前台的页面应该怎么写？先是一个表单中会有两个按钮：</p>
<pre><code>&lt;form action=&quot;${ pageContext.request.contextPath }/uploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;添加&quot; onclick=&quot;add()&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
    &lt;div id = &quot;div1&quot;&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre><p>然后点击添加按钮是会有新的文件选择框以及对应的删除按钮出现：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function add() {
        var div1 = document.getElementById(&quot;div1&quot;);
        div1.innerHTML += &quot;&lt;div&gt;&lt;input type=&apos;file&apos; name=&apos;upload&apos;&gt;&lt;input type=&apos;button&apos; value=&apos;删除&apos; onclick=&apos;del(this)&apos;&gt;&lt;/div&gt;&quot;;
    }
&lt;/script&gt;
</code></pre><p>最后当然就是我们点击删除按钮时，会删除掉删除按钮本身以及前面的文件选择框了，其实就是还需要添加一个 <code>js</code> 方法。</p>
<pre><code>function del(who) {
    var divv = who.parentNode;
    divv.parentNode.removeChild(divv);
}
</code></pre><p>这样的话，前台页面就达到要求了，那后台代码呢？其实后台代码是不需要改变的，因为不管我们在前台添加多少个文件选择框，在后台解析的时候，都是遍历处理的，因此是没有问题的。</p>
<h3 id="8-文件上传相关问题"><a href="#8-文件上传相关问题" class="headerlink" title="8.文件上传相关问题"></a>8.文件上传相关问题</h3><p>下面我们再看看进行文件上传时，可能会出现的问题，第 <code>1</code> 个就是对于一些比较老的浏览器来说，当我们使用 <code>FileItem</code> 类中的 <code>getName()</code> 方法获取文件名时，这时候文件名中可能是带有路径的，比如说 <code>D://aa.txt</code>，而现在的浏览器一般都是 <code>aa.txt</code>，因此我们就需要兼顾这两种情况。</p>
<pre><code>String fileName = fileItem.getName();
int idx = fileName.lastIndexOf(&quot;\\&quot;);
if (idx != -1) {
    fileName = fileName.substring(idx + 1);
}
</code></pre><p>这样的话，文件名中带有路径的问题就解决了。</p>
<p>第 <code>2</code> 个问题那就是文件同名的问题，比如有两个用户，他们都上传了 <code>aa.txt</code> 这个名称的文件，但是它们各自上传的文件里面的内容是不一样的，如果我们不做处理的话，肯定就会发生文件覆盖的情况，这样肯定是有问题的，因此我们就需要解决这个问题。</p>
<p>要想解决这个问题，我们可以进行文件名的转换，比如说小明这个用户上传了一个 <code>aa.txt</code> 的文件的话，那我们可以将这个文件的名称转换为一个唯一的名称，比如 <code>4817717ad590496bb93850bc9e198494.txt</code>，而小红这个用户也上传一个 <code>aa.txt</code> 的话，那我们也可以同样的进行转换，比如为 <code>76519c284323424aa6a353e382ba528e.txt</code>，这样的话即使两个用户上传的文件名是一样的，我们也可以进行区分了，也许有人会说，那你这样转换了之后，原来的文件名你不是拿不到了，其实在实际的开发过程中，我们可以将转换前的文件名和转换后的文件名都存入到数据库中，这样当用户需要取自己的文件时，再使用自己原来的文件名也就好了。关于获得唯一文件名的方法，我们可以先简单地使用 <code>UUID</code> 这个类来生成：</p>
<pre><code>public static String getUuidFileName(String fileName) {
    String preFileName = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
    int idx = fileName.lastIndexOf(&quot;.&quot;);
    String extFileName = fileName.substring(idx);
    return preFileName + extFileName;
}
</code></pre><p>下面再看第 <code>3</code> 个问题，就是一个目录中可能存放的文件个数过多，那我们要做的就是不要将文件全部放到一个目录中了，而是应该将文件分开存放，那我们应该采用怎样的方式来进行区分呢？其实可以按下面这些：</p>
<pre><code>按时间来分：按月、日、小时来分
按用户来分：每个用户都有自己的文件目录
按个数来分：一个目录里面只存放固定数目的文件
</code></pre><p>下面想要介绍一种算法来确定文件存放的目录，首先还是将原文件名根据上面的方法转换为唯一的文件名，然后取它的 <code>hashCode</code> 值，当然就是一个 <code>int</code> 类型数据了，所以应该是一个 <code>32</code> 位的数据，然后我们就可以使用该 <code>hashCode</code> 值与 <code>0xf</code> 做位的与运算，这样就可以得到一个 <code>0</code> 到 <code>15</code> 之间的数，我们就将该数作为第一级目录，接下来我们将 <code>hashCode</code> 值无符号右移 <code>4</code> 位，再与 <code>0xf</code> 做位的与运算，这样得到的数作为第二级目录，因为 <code>hashCode</code> 值只有 <code>32</code> 位，因此肯定就只能运算 <code>8</code> 次，那我们就可以得到一个 <code>8</code> 级的目录了，想一下，有 <code>8</code> 级目录，每一级目录有 <code>0</code> 到 <code>15</code> 这 <code>16</code> 种取值，这样算的话，我们可以得到的总目录个数就是 <code>16</code> 的 <code>8</code> 次方了，很显然是可以满足我们的要求的。</p>
<pre><code>public static String getRealPath(String uuidFileName) {
    int hashCode = uuidFileName.hashCode();
    int count = 0;
    StringBuffer stringBuffer = new StringBuffer();
    while (count &lt; 8) {
        stringBuffer.append(&quot;/&quot;);
        int result = hashCode &amp; 0xf;
        stringBuffer.append(result);
        hashCode &gt;&gt;&gt;= 4;
        count++;
    }
    return stringBuffer.toString();
}
</code></pre><h3 id="9-文件下载简介"><a href="#9-文件下载简介" class="headerlink" title="9.文件下载简介"></a>9.文件下载简介</h3><p>上面已经介绍了文件上传，下面就开始介绍文件下载了，其实文件下载也是非常常用的功能了，因为我们可能就会经常使用，比如音乐或者电影的下载，因此掌握了之后也能为我们写的网站添彩，其实文件下载功能的实现也是非常简单的。</p>
<p>其实文件下载的话就是将服务器上面的文件通过文件流的方式写到本地磁盘中，实现的方式有以下两种：</p>
<pre><code>1.通过超链接的方式进行下载；
2.使用手动编码的方式进行下载。
</code></pre><p>下面我们分别开始介绍。</p>
<h3 id="10-使用超链接方式进行下载"><a href="#10-使用超链接方式进行下载" class="headerlink" title="10.使用超链接方式进行下载"></a>10.使用超链接方式进行下载</h3><p>下载文件的话，首先服务器上面肯定是需要有文件的，因此我们就可以在 <code>WebContent</code> 下面新建一个 <code>download</code> 目录，然后在其中放入 <code>1.jpg</code> 图片和 <code>aa.zip</code> 压缩文件，这样的话，我们就可以下载这两个文件了。</p>
<p>而使用超链接的方式实现文件下载的话，就可以直接在前台页面写如下的代码：</p>
<pre><code>&lt;h2&gt;文件下载：超链接方式&lt;/h2&gt;
&lt;h3&gt;
    &lt;a href=&quot;${ pageContext.request.contextPath }/download/1.jpg&quot;&gt;1.jpg&lt;/a&gt;
&lt;/h3&gt;
&lt;h3&gt;
    &lt;a href=&quot;${ pageContext.request.contextPath }/download/aa.zip&quot;&gt;aa.zip&lt;/a&gt;
&lt;/h3&gt;
</code></pre><p>这样的话，就可以了，是的，只需要在前台使用 <code>a</code> 这个超链接标签就可以完成下载功能了，就是这么简单，不过需要说明的是，这种超链接下载文件的方式，有一个缺点就是，如果我们下载的是浏览器不支持的文件的话，那么浏览器就会提示我们进行下载了，但是如果我们下载的文件是浏览就支持的话，比如图片等，那浏览器就不会提示下载，而是直接打开了，因此这一点是需要注意的。</p>
<h3 id="11-手动编码方式实现文件下载"><a href="#11-手动编码方式实现文件下载" class="headerlink" title="11.手动编码方式实现文件下载"></a>11.手动编码方式实现文件下载</h3><p>要想使用编码方式实现下载的话，是需要满足一定条件的，需要设置响应对象的两个响应头和获得下载文件的输入流。</p>
<pre><code>Content-Type：下载文件的MIME类型
Content-Disposition：设置该属性之后，即使是浏览器支持的文件格式，也会提示下载
下载文件的输入流，因为输出流是固定的，都是给浏览器端的
</code></pre><p>下面就直接看代码了，首先看前端的页面代码：</p>
<pre><code>&lt;h2&gt;文件下载：编码方式&lt;/h2&gt;
&lt;h3&gt;
    &lt;a href=&quot;${ pageContext.request.contextPath }/downloadServlet?fileName=1.jpg&quot;&gt;1.jpg&lt;/a&gt;
&lt;/h3&gt;
&lt;h3&gt;
    &lt;a href=&quot;${ pageContext.request.contextPath }/downloadServlet?fileName=aa.zip&quot;&gt;aa.zip&lt;/a&gt;
&lt;/h3&gt;
</code></pre><p>然后就是后台的代码了：</p>
<pre><code>// 1.接受参数
String fileName = request.getParameter(&quot;fileName&quot;);
// 2.下载文件：设置两个头和一个流
// 设置Content-Type
String type = this.getServletContext().getMimeType(fileName);
response.setContentType(type);
// 设置Content-Disposition
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;
        + fileName);
String realPath = this.getServletContext().getRealPath(&quot;/download&quot;);
String newPath = realPath + &quot;/&quot; + fileName;
// 获得文件的输入流
InputStream is = new FileInputStream(newPath);
ServletOutputStream os = response.getOutputStream();
int len = 0;
byte[] bytes = new byte[1024];
while ((len = is.read(bytes)) != -1) {
    os.write(bytes);
}
is.close();
</code></pre><p>首先是设置 <code>Content-Type</code> 这个响应头，应该是设置文件类型所对应的 <code>MIME</code> 类型，当然我们的 <code>ServletContext</code> 对象是提供了方法根据文件名来获取对应的 <code>MIME</code> 类型的，也就是 <code>getMimeType()</code> 方法，其实文件的 <code>MIME</code> 类型是在 <code>Tomcat</code> 服务器的配置文件 <code>web.xml</code> 中进行配置的；接下来便是 <code>Content-Disposition</code> 这个响应头的设置，其实设置这个响应头时，很大一部分都是固定不变的，也就是 <code>attachment;filename=</code>，后面则是需要加上文件名了；最后的话则是需要获取到下载文件的输入流了，然后和我们的响应流 <code>response.getOutputStream()</code> 进行对接，这样就可以完成文件下载的功能了。</p>
<h3 id="12-中文文件的下载"><a href="#12-中文文件的下载" class="headerlink" title="12.中文文件的下载"></a>12.中文文件的下载</h3><p>如果要想能够顺利下载中文文件的话，那肯定就要考虑到中文字符乱码的问题了，以及各个浏览器对中文字符编码的方式了。</p>
<p>首先，如果下载文件的文件名是中文的话，那我们在后台获取文件名时，就应该要考虑到这种情况了，因此可以使用如下的代码。</p>
<pre><code>// 1.接受参数
String fileName = new String(request.getParameter(&quot;fileName&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
</code></pre><p>下面再看关于不同浏览器对于中文字符不同的编码方式，其实这里可以分为 <code>2</code> 种：</p>
<pre><code>1.火狐浏览器是使用的Base64编码
2，其它浏览器，如IE、Chrome则是使用的URL编码
</code></pre><p>知道了这两种区别之后，那我们应该如何在代码中进行区分呢？其实是可以利用请求对象中的 <code>User-Agent</code> 这个请求头的，如果该请求头中包含 <code>Firefox</code> 这个字符串的话，那肯定就是火狐浏览器了，而其它的我们就可以采用另一种编码方式了，因此这样的话就可以区分出来了。</p>
<p>需要说明一下的是，对于火狐浏览器采用的 <code>Base64</code> 编码方式，我们这里可以使用一个 <code>DownloadUtil</code> 工具类，然后在其中提供一个 <code>Base64</code> 的编码方法，这样就可以满足我们的要求了，具体方法可以如下：</p>
<pre><code>public static String base64EncodeFileName(String fileName) {
    BASE64Encoder base64Encoder = new BASE64Encoder();
    try {
        return &quot;=?UTF-8?B?&quot;
                + new String(base64Encoder.encode(fileName
                        .getBytes(&quot;UTF-8&quot;))) + &quot;?=&quot;;
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
        throw new RuntimeException(e);
    }
}
</code></pre><p>这个就是针对火狐浏览器时所需要使用的编码方式了，下面则是 <code>IE</code> 或者其它浏览器采用 <code>URL</code> 编码方式的情况了。</p>
<pre><code>fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);
</code></pre><p>那么我们设置 <code>Content-Disposition</code> 时比较完整的代码就应该是下面这样了。</p>
<pre><code>// 设置Content-Disposition
String agent = request.getHeader(&quot;User-Agent&quot;);
if (agent.contains(&quot;Firefox&quot;)) {
    // 是火狐浏览器
    fileName = DownloadUtil.base64EncodeFileName(fileName);
} else {
    // 其它浏览器
    fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);
}
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+ fileName);
</code></pre><p>为了能够下载中文名的文件，那我们的代码整体上也应该进行一些调整。</p>
<pre><code>// 1.接受参数
String fileName = new String(request.getParameter(&quot;fileName&quot;).getBytes(
        &quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
// 2.下载文件：设置两个头和一个流
// 设置Content-Type
String type = this.getServletContext().getMimeType(fileName);
response.setContentType(type);
String realPath = this.getServletContext().getRealPath(&quot;/download&quot;);
String newPath = realPath + &quot;/&quot; + fileName;
// 设置Content-Disposition
String agent = request.getHeader(&quot;User-Agent&quot;);
if (agent.contains(&quot;Firefox&quot;)) {
    // 是火狐浏览器
    fileName = DownloadUtil.base64EncodeFileName(fileName);
} else {
    // 其它浏览器
    fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);
}
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;
        + fileName);
// 获得文件的输入流
InputStream is = new FileInputStream(newPath);
ServletOutputStream os = response.getOutputStream();
int len = 0;
byte[] bytes = new byte[1024];
while ((len = is.read(bytes)) != -1) {
    os.write(bytes);
}
is.close();
</code></pre><h3 id="13-案例：给定目录下文件下载"><a href="#13-案例：给定目录下文件下载" class="headerlink" title="13.案例：给定目录下文件下载"></a>13.案例：给定目录下文件下载</h3><p>我们现在想做的就是在页面中显示某个目录中所有的文件，并且当我们在页面中点击文件名称时，可以进行下载操作，那这样的话，其实是应该分为两部分的，第一部分就应该是显示某个目录中的所有文件列表，而且如果是多级目录的话，也应该能够遍历的到，第二部分则是下载操作了。</p>
<p>首先看看显示文件的部分，由于可能多级目录的存在，因此我们可以使用一个队列来存放我们需要遍历的目录，首先将根目录放到队列当中，然后就是遍历该队列，查看目录中的所有文件和目录，如果是文件的话，那就直接显示在页面上，而如果是目录的话，那就可以先加入到队列当中，以便再次进行循环。</p>
<p>下面直接看代码：</p>
<pre><code>&lt;%
    // 1.创建一个队列
    Queue&lt;File&gt; queue = new LinkedList&lt;File&gt;();
    // 2.将根节点入队
    File root = new File(&quot;D://Blog&quot;);
    queue.offer(root);
    // 3.对队列进行循环遍历
    while (!queue.isEmpty()) {
        File file = queue.poll();
        File[] files = file.listFiles();
        for (File f : files) {
            if (f.isFile()) {
%&gt;
&lt;h4&gt;
    &lt;a
        href=&quot;${ pageContext.request.contextPath }/downloadListServlet?fileName=&lt;%=f.getCanonicalPath()%&gt;&quot;&gt;&lt;%=f.getName()%&gt;&lt;/a&gt;
&lt;/h4&gt;
&lt;%
    } else {
                queue.offer(f);
            }
        }
    }
%&gt;
</code></pre><p>需要注意的一点就是因为各个文件所在的目录可能不一致，因此我们向后台 <code>Servlet</code> 发送请求时，就直接使用 <code>getCanonicalPath()</code> 方法获得文件的带路径完整文件名，这样在后台代码中也便于处理。</p>
<p>下面则是后台代码：</p>
<pre><code>String path = new String(request.getParameter(&quot;fileName&quot;).getBytes(
    &quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
File file = new File(path);
String fileName = file.getName();
String type = this.getServletContext().getMimeType(fileName);
response.setContentType(type);
String agent = request.getHeader(&quot;User-Agent&quot;);
if (agent.contains(&quot;Firefox&quot;)) {
    fileName = DownloadUtil.base64EncodeFileName(fileName);
} else {
    fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;);
    fileName = fileName.replace(&quot;+&quot;, &quot; &quot;);
}
response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;
        + fileName);
// 设置输入流
InputStream is = new FileInputStream(path);
OutputStream os = response.getOutputStream();
int len = 0;
byte[] bytes = new byte[1024];
while ((len = is.read(bytes)) != -1) {
    os.write(bytes, 0, len);
}
is.close();
</code></pre><p>因此这个案例也就写完了，其实和前面下载一个文件也是没什么实质区别的。</p>
<h3 id="14-总结"><a href="#14-总结" class="headerlink" title="14.总结"></a>14.总结</h3><p>文件的上传和下载就介绍完了，其实只要遵循相应的规则，也就能很容易实现我们想要的功能了，比如文件上传时表单需要满足哪些要素，然后就是 <code>FileUpload</code> 这个工具使用的步骤，掌握了这些也就可以掌握文件上传了，而文件下载时，则是需要设置两个响应头和获得一个文件的输入流，这样的话也就能掌握文件下载的实现了，其实很多东西都是这样，只要能掌握其中最基本的步骤就好办了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JSP/" rel="tag"># JSP</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/24/Listener和Filter/" rel="next" title="Listener和Filter">
                <i class="fa fa-chevron-left"></i> Listener和Filter
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/08/jQuery的使用-一/" rel="prev" title="jQuery的使用(一)">
                jQuery的使用(一) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/logo.jpg"
               alt="Lau Cloud" />
          <p class="site-author-name" itemprop="name">Lau Cloud</p>
           
              <p class="site-description motion-element" itemprop="description">想保护一个人</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/LauCloud" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-文件上传简介"><span class="nav-number">1.</span> <span class="nav-text">1.文件上传简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-文件上传的原理"><span class="nav-number">2.</span> <span class="nav-text">2.文件上传的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-文件上传的代码实现"><span class="nav-number">3.</span> <span class="nav-text">3.文件上传的代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-DiskFileItemFactory-磁盘文件项工厂"><span class="nav-number">4.</span> <span class="nav-text">4.DiskFileItemFactory(磁盘文件项工厂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-ServletFileUpload-核心解析类"><span class="nav-number">5.</span> <span class="nav-text">5.ServletFileUpload(核心解析类)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-FileItem-文件项"><span class="nav-number">6.</span> <span class="nav-text">6.FileItem(文件项)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-案例：多文件上传"><span class="nav-number">7.</span> <span class="nav-text">7.案例：多文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-文件上传相关问题"><span class="nav-number">8.</span> <span class="nav-text">8.文件上传相关问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-文件下载简介"><span class="nav-number">9.</span> <span class="nav-text">9.文件下载简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-使用超链接方式进行下载"><span class="nav-number">10.</span> <span class="nav-text">10.使用超链接方式进行下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-手动编码方式实现文件下载"><span class="nav-number">11.</span> <span class="nav-text">11.手动编码方式实现文件下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-中文文件的下载"><span class="nav-number">12.</span> <span class="nav-text">12.中文文件的下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-案例：给定目录下文件下载"><span class="nav-number">13.</span> <span class="nav-text">13.案例：给定目录下文件下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-总结"><span class="nav-number">14.</span> <span class="nav-text">14.总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lau Cloud</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'laucloudparty';
      var disqus_identifier = '2017/12/28/文件上传和下载/';

      var disqus_title = "文件上传和下载";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  










  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("HOfS0Gs4yDR8hYgXvwhoQatu-gzGzoHsz", "Hpz44Tn78X4lsNc34GD6Rl1v");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


  

</body>
</html>
